diff --git a/contrib/postgres_fdw/Makefile b/contrib/postgres_fdw/Makefile
index d2b98e1..5866988 100644
--- a/contrib/postgres_fdw/Makefile
+++ b/contrib/postgres_fdw/Makefile
@@ -5,7 +5,7 @@ OBJS = postgres_fdw.o option.o deparse.o connection.o $(WIN32RES)
 PGFILEDESC = "postgres_fdw - foreign data wrapper for PostgreSQL"
 
 PG_CPPFLAGS = -I$(libpq_srcdir)
-SHLIB_LINK = $(libpq)
+SHLIB_LINK = -lcrypto $(libpq)
 
 EXTENSION = postgres_fdw
 DATA = postgres_fdw--1.0.sql
diff --git a/contrib/postgres_fdw/connection.c b/contrib/postgres_fdw/connection.c
index 1a1e5b5..24b4f23 100644
--- a/contrib/postgres_fdw/connection.c
+++ b/contrib/postgres_fdw/connection.c
@@ -20,6 +20,12 @@
 #include "utils/hsearch.h"
 #include "utils/memutils.h"
 
+#include <openssl/rsa.h>
+#include <openssl/engine.h>
+#include <openssl/pem.h>
+
+#define PADDING RSA_PKCS1_PADDING
+
 
 /*
  * Connection cache hash table entry
@@ -75,6 +81,12 @@ static void pgfdw_subxact_callback(SubXactEvent event,
 					   SubTransactionId parentSubid,
 					   void *arg);
 
+RSA* loadPrivateKeyFromString(char *privateKeyString, int length);
+char* rsaDecrypt(RSA *privateKey, unsigned char *encryptedBin, int *decryptedLen);
+int base64DecodeLength(char *b64String);
+char* base64Decode(char *input, int length);
+char* shiftChars(char *inString, int shiftBy);
+char* decryptPassword(char *base64Encrypted, int base64EncryptedLen);
 
 /*
  * Get a PGconn which can be used to execute queries on the remote PostgreSQL
@@ -271,6 +283,106 @@ connect_pg_server(ForeignServer *server, UserMapping *user)
 	return conn;
 }
 
+RSA* loadPrivateKeyFromString(char *privateKeyString, int length)
+{
+	BIO *bio = BIO_new_mem_buf((void*)privateKeyString, length);
+	RSA* rsaPrivateKey = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
+
+	if (!rsaPrivateKey)
+		printf("ERROR: Could not load Private KEY!  PEM_read_bio_RSAPrivateKey FAILED: %s\n", ERR_error_string(ERR_get_error(), NULL));
+
+	BIO_free(bio);
+	return rsaPrivateKey;
+}
+
+char* rsaDecrypt(RSA *privateKey, unsigned char *encryptedBin, int *decryptedLen)
+{
+	int rsaLen = RSA_size(privateKey); // That's how many bytes the decrypted data would be
+
+	unsigned char *decryptedBin = (unsigned char*)malloc(rsaLen);
+	*decryptedLen = RSA_private_decrypt(RSA_size(privateKey), encryptedBin, decryptedBin, privateKey, PADDING);
+	if(*decryptedLen == -1)
+		printf("ERROR: RSA_private_decrypt: %s\n", ERR_error_string(ERR_get_error(), NULL));
+
+	return (char*)decryptedBin;
+}
+
+int base64DecodeLength(char *b64String)
+{
+	int len = strlen(b64String);
+	int padding = 0;
+
+	if (b64String[len-1] == '=' && b64String[len-2] == '=') // Last two chars are =
+		padding = 2;
+	else if (b64String[len-1] == '=') // Last char is =
+		padding = 1;
+
+	return (int)len*0.75 - padding;
+}
+
+char* base64Decode(char *input, int length)
+{
+	BIO *b64, *bmembuf;
+	char *binOut = (char *)malloc(length+1);
+	memset(binOut, 0, length + 1);
+	b64 = BIO_new(BIO_f_base64());
+	bmembuf = BIO_new_mem_buf(input, length);
+	bmembuf = BIO_push(b64, bmembuf);
+	BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+	BIO_read(bmembuf, binOut, length);
+	//binOut[length] = '\0';
+	BIO_free_all(bmembuf);
+	return binOut;
+}
+
+char* shiftChars(char *inString, int shiftBy)
+{
+	int charIndex;
+	int inStringLen = strlen(inString);
+	char *shifted = malloc(inStringLen + 1);
+	memset(shifted, 0, inStringLen + 1);
+	for(charIndex = 0; charIndex < inStringLen; charIndex++)
+	{
+		if (inString[charIndex] == 10)
+			shifted[charIndex] = 10;
+		else
+			shifted[charIndex] = inString[charIndex] + shiftBy;
+	}
+	return shifted;
+}
+
+char* decryptPassword(char *base64Encrypted, int base64EncryptedLen)
+{
+	char *privateKeyB64B64ShiftedB64Shifted = "XIf3hIE[QXgZZZkRZJ4JY4n3VZw]Vn8RZp<NZY][UoEZZp<7XIf3hIEYgIM[Z[EN]3oNWoYyVn][QIMJZYodUoIdYn{gZ38LYZ8JWIo|dH<]e3syZ6IzYZX3RGk\\QKQ5dYf<eokMQWYUQY]yZnorgpgf[[wrZ4]:YYwhWoH3hKUKfJv8Yo{dZZ]MRX8de4M]X4oViok]QYQdZH]{]qMhU4oOZmk\\e6U]Yq8UiX;5gH]ZfX8OZokZWpoyfGU[[I]4[Z<yQYwN[nk\\Z473Yp8dgpkdZqUUY}{SZnoZioszZqQgQqv3ZHkvio8xZo{]ion5]Z8vXIj3R[4eZZ;4Y4f<YZk.Xq8[foMPYosvgZ]\\[n8Yfo]{Zp8R[YH6Wq]pV6UXdXkRhYkPUnkYZor3ZXY3Y4oMV[ssVWY7]m]uiI]wg}]gZoMhZXsVZYgxfI{ZQp{[Xp8vWo]eX[8Ve}4KYoozeH;5RK]sfpg:X3v4X4sNYn{]Q4M9Y[8JZ5]{S[YdQ[U7Zov4[XgyYn]oQG4{Z[8qgo4{iIoqZ6T4XY{rRYf4fHw[fW4MZp<dU4Q[hGgTQYs<ZmUrgZf4[qYVZYMy]6Mz[IodYmspVW4|]6INWosNfH4pVX8xXXv4QYMOXX<YQp<5X3wyh433e}ggQpkdZno7hYr5dKQrZ6EW]qE3VIw]QWgrZIsJXYn<gIH3Xn]qfpkRYnoNYoY]Wn]pQKEKYYohgYw{QX{\\WJz9XooZeYwxV[wqd6T3dKMhhYIyWnk[fH8SYnwNQoMeXowZQG43]X{RX4E.[oIpVXsSZqH<VY8eZn<WZI]YZqE]iIsOiIE\\V[f7Xnkz]Y4fdJ<[Voo<ZXogQI]NXq]W[J<9U6IqQJkzeIsefo]S]nn<VYj3SGY\\fWo]XXsZQ4wLe64\\eW4W]YkMQYr3Zqs]fpkSZJ<7[IX4WWosVIsR[[I;WpgLUmk]Q38MXosMiYIxXmkhVWYMdGUuW4gNdK{ZVI]\\Xp;3RY4eW[4]fqD3ZqEMh4kLWpY[f[U<dJ8gRJ]yXqY[Zo88Z4{rW5kdUoIUQY8vZof<W5kPUmk]Q4]ZXowvgJg\\XnsUQmYJdYn;QYI:gHsTQo4:XGT<gpYy]}oUfIs{ZIw;WZYddK4Ufpk6XmghY5oNfII[VXs3X3wNU4MNgJ4oZWY5ZIszZYwyXnwTQqE[Z6MJWJ]fd6{hZ3s|]X{rg4YyhHsKf[kPXm]3eo33Vn{TQKg:]4{rXZYfWngrVX8[]qEJW5o[hK]pWI83]WYIQYgxVWgqV[EVW}]dZog|[modQo8UZ3{rgor4UoIse[kMXXs3gZk]e68sZH4SdXo3iIg.XoMZZYM|Z4odUoL5eH{eZn79]3oN[IYdU[w[Qo]xY[Ev[I]{RGooZI]4[nv7gp]NdGYVfoX3dH{MhpYN[q4gfWY:]5;<h4YeQGooWIMXZnY3hokM[msdep{:Ym\\<iYkNZp8ge}YO]qERf4M.Zok[fos.Z6IZZ5kd[o4oe4syXnwURIo|Vp<oQKkfZ3kzfIkMd6wYfYM3[WYJV44\\eHkoQo]4X3kN[ngzWoshVI]MZn{]RYYdXosp[I8YZH{gQpkOQ[UrQ4r9]3kviZgeYqg[Vo\\5Z5<riJk]fI{pQJ{8ZowNgJf4dK8heo]wXG]QQoILeHkhQ[ENYYkdZoY{[X<hfno5]}gN]Yj6XokVfno9ZmYReIIySY{\\[IX3Z3v4WY8LW[4YZZj6]Y{JXo]PeKk]QHs3]owNYJYPWoIgf[kh[qI;goI]YoQYQKE.ZHoyiIM|eIkpU[T6XmU3eZkLdKYrVZ{fZn{NYY8\\dKUUV}j7]m]3eIoPYmkdWH\\4]Xw]go]zfH8rfY37]nw:goj6U[8gfW4hZmgUgosfZqYqQHn3X3sziJg{ZWg[ens;U6H8ZIY{gH8s[Io:Z5<vf4f5[o{dZX38Z5<zYJkeeJ{\\fIMSXXn<[JYNYWgoY}z5ZqEJXI]]XqMeZX8edX{RepX3hK8]VpkV]q8]RZg]h}k]Z[D9YqMgW4]MQG]rQG47dIwViIkzX[w[Zn]wZW\\4W5gxZok[U}4y]}U;gIQ\\Xq{he6U[Zos}iZj5fI4dV[T9Z3n<Y4wxfKo[iqEZdGUVepY|fJ{gQI4:Z[MJXYg:f}oZZ6{{ZYwNZII\\Yq]][I8]dIwdW48z[mkpZ379XGURQZYx[mkhZ6v3]}]7Uon5Xo{YZ[{Z[Z8uRYr4Zm]UQKE5X[EJWI35Yn]de6kyY3{hV4gOWo]Kfns8ZKEhVYkP[mspZ4s3dYv8f4k{YqwpZXso]n{rXIY{dI]YQ5kodYw;Zokz[[]gZZkZdZ<VXIk]Vo{oQI8}]n{RgoYxWmYZQm4oXo{VX5]OfKI\\QG{SZHkNQoo\\X[sWVor8Y4{QQIwfZWY\\VXr3XGUd[Yw\\ZqMUV[{LZm];Wpk\\fH{sfZ{3YqIVZoH3ZqQoQHo:Z[H8QYj4eIgSQIsYXq8qho4fYqMZQqw5Xpw3[IQOYo{ZepkMW68qRJg.ZWgge[kyYoo7Q4Y.Y[]Zfn]edI{qh5YyXqUpZ5kfXov8fIkyYoweZ}z5Y3odXZkMXoUZZ[U7dXn4[Jj5X[{[VXo;ZqE}gng{Xp8efnsRZYo7U474VnkeVX75dYkdgpk|UoIZeo8h[ov8eYf6[p8pens4YWgReoD3RYgU[I]fd[MUQY4yeIw\\QYs4W}YrYog|Uo{[QY]TZ3v7QIo]h3<qfJkKZog7Xp]NYo]\\fnsgXWUdVZ\\3[mkTiqENdKIVZJgdWn4q[KU]Z6MvZ5kyiJ<ofIsXXnw3gYn6Vq{pQ385dKI;iY33QWg]VoY9]n{NgIIeQZ8pU[P8[o{hQ4]{SZ4Ufp{SZnv<iYsdVo{ZVp;3ZYkrYYw{eKUe[JkgX[MMRYkPYWoSQKw5YqEdQIwxUmsoQqUPY3wViIo\\XmooV5f<YIY}hIE[QKkTZYsWYngJY4n3VZw]Vn8RZp<NZY][UoEZZp<7XIf3hIEYf3H@";
+	char *privateKeyB64B64ShiftedB64 = shiftChars(privateKeyB64B64ShiftedB64Shifted, -3);
+	char *privateKeyB64B64Shifted = base64Decode(privateKeyB64B64ShiftedB64, strlen(privateKeyB64B64ShiftedB64Shifted));
+	char *privateKeyB64B64 = shiftChars(privateKeyB64B64Shifted, -4);
+	char *privateKeyB64 = base64Decode(privateKeyB64B64, strlen(privateKeyB64B64));
+	RSA *privateKey;
+	char *passwordBin;
+	int decryptedDataLen;
+	char *decryptedData;
+	memset(privateKeyB64B64ShiftedB64, 0, strlen(privateKeyB64));
+	memset(privateKeyB64B64Shifted, 0, strlen(privateKeyB64));
+	memset(privateKeyB64B64, 0, strlen(privateKeyB64));
+	privateKey = loadPrivateKeyFromString(privateKeyB64, strlen(privateKeyB64));
+	memset(privateKeyB64, 0, strlen(privateKeyB64));
+
+	passwordBin = base64Decode(base64Encrypted, base64EncryptedLen);
+	
+	decryptedData = rsaDecrypt(privateKey, (unsigned char *) passwordBin, &decryptedDataLen);
+	decryptedData[decryptedDataLen] = '\0';
+
+	RSA_free(privateKey);
+	free( privateKeyB64B64ShiftedB64 );
+	free( privateKeyB64B64Shifted );
+	free( privateKeyB64B64 );
+	free( privateKeyB64 );
+	free( passwordBin );
+
+	return decryptedData;
+}
+
 /*
  * For non-superusers, insist that the connstr specify a password.  This
  * prevents a password from being picked up from .pgpass, a service file,
@@ -283,6 +395,16 @@ check_conn_params(const char **keywords, const char **values)
 {
 	int			i;
 
+	/* find password and decrypt it. */
+	for (i = 0; keywords[i] != NULL; i++)
+	{
+		if (strcmp(keywords[i], "password") == 0 && values[i][0] != '\0')
+		{
+			values[i] = decryptPassword((char *)values[i], strlen(values[i]));
+			return;
+		}
+	}
+
 	/* no check required if superuser */
 	if (superuser())
 		return;
